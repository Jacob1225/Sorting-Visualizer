{"ast":null,"code":"import { useState, useEffect } from \"react\";\nexport default function useApplicationData() {\n  //This custom hook is the beiung used to manage the overall data of the app.\n  const [state, setState] = useState({\n    array: []\n  }); //function that generates a new array with randomized numbers\n\n  function resetArray() {\n    let array = [];\n\n    for (let i = 0; i <= 290; i++) {\n      array.push(Math.floor(Math.random() * (900 - 5 + 1) + 5));\n    }\n\n    setState({\n      array\n    });\n  }\n\n  ; //Once the comonpent loads \n\n  useEffect(() => {\n    resetArray();\n  }, []); //Function that is responsible for comparing the left and right arrays then returning the sortedarray\n\n  function merge(left, right) {\n    let sortedArray = []; //Looping until one of the arrays has reached 0 elements\n\n    while (left.length && right.length) {\n      if (left[0] < right[0]) {\n        sortedArray.push(left.shift());\n      } else {\n        sortedArray.push(right.shift());\n      }\n    } //Using the spread operator to concat the sorted elements, with the left and right arrays\n\n\n    return [...sortedArray, ...left, ...right];\n  }\n\n  ; //Main that takes an unsorted array as input and uses recursion to sort it in ascending order\n\n  function mergeSort(arr) {\n    //If the array has 1 or 0 elements then exit out of the function\n    if (arr.length <= 1) {\n      return arr;\n    } //Create the left and right arrays by splitting the original array in the middle\n\n\n    const middle = Math.floor(arr.length / 2);\n    let left = arr.slice(0, middle);\n    let right = arr.slice(middle); //Return the sorted array from the merge function\n\n    let array = merge(mergeSort(left), mergeSort(right));\n    setState({\n      array\n    });\n  }\n\n  ;\n  return {\n    state,\n    resetArray,\n    mergeSort\n  };\n}","map":{"version":3,"sources":["/Users/jacobcarlone/lighthouse1/Sorting-Visualizer/sorting-visualizer/src/hooks/useApplicationData.jsx"],"names":["useState","useEffect","useApplicationData","state","setState","array","resetArray","i","push","Math","floor","random","merge","left","right","sortedArray","length","shift","mergeSort","arr","middle","slice"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AAGA,eAAe,SAASC,kBAAT,GAA6B;AAExC;AACA,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,QAAQ,CAAC;AAC/BK,IAAAA,KAAK,EAAE;AADwB,GAAD,CAAlC,CAHwC,CAOxC;;AACA,WAASC,UAAT,GAAqB;AACjB,QAAID,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,GAArB,EAA0BA,CAAC,EAA3B,EAA8B;AAC1BF,MAAAA,KAAK,CAACG,IAAN,CAAWC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiB,MAAM,CAAN,GAAU,CAA3B,IAAgC,CAA3C,CAAX;AACH;;AACDP,IAAAA,QAAQ,CAAC;AAAEC,MAAAA;AAAF,KAAD,CAAR;AACH;;AAAA,GAduC,CAgBxC;;AACAJ,EAAAA,SAAS,CAAC,MAAM;AACZK,IAAAA,UAAU;AACb,GAFQ,EAEN,EAFM,CAAT,CAjBwC,CAqBxC;;AACA,WAASM,KAAT,CAAeC,IAAf,EAAqBC,KAArB,EAA4B;AACxB,QAAIC,WAAW,GAAG,EAAlB,CADwB,CAGxB;;AACA,WAAOF,IAAI,CAACG,MAAL,IAAeF,KAAK,CAACE,MAA5B,EAAoC;AAChC,UAAIH,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACpBC,QAAAA,WAAW,CAACP,IAAZ,CAAiBK,IAAI,CAACI,KAAL,EAAjB;AACH,OAFD,MAEO;AACHF,QAAAA,WAAW,CAACP,IAAZ,CAAiBM,KAAK,CAACG,KAAN,EAAjB;AACH;AACJ,KAVuB,CAWxB;;;AACA,WAAO,CAAC,GAAGF,WAAJ,EAAiB,GAAGF,IAApB,EAA0B,GAAGC,KAA7B,CAAP;AACH;;AAAA,GAnCuC,CAqCxC;;AACA,WAASI,SAAT,CAAmBC,GAAnB,EAAwB;AAEpB;AACA,QAAIA,GAAG,CAACH,MAAJ,IAAc,CAAlB,EAAqB;AACrB,aAAOG,GAAP;AACC,KALmB,CAOpB;;;AACA,UAAMC,MAAM,GAAGX,IAAI,CAACC,KAAL,CAAWS,GAAG,CAACH,MAAJ,GAAa,CAAxB,CAAf;AACA,QAAIH,IAAI,GAAGM,GAAG,CAACE,KAAJ,CAAU,CAAV,EAAaD,MAAb,CAAX;AACA,QAAIN,KAAK,GAAGK,GAAG,CAACE,KAAJ,CAAUD,MAAV,CAAZ,CAVoB,CAYpB;;AACA,QAAIf,KAAK,GAAGO,KAAK,CAACM,SAAS,CAACL,IAAD,CAAV,EAAkBK,SAAS,CAACJ,KAAD,CAA3B,CAAjB;AACAV,IAAAA,QAAQ,CAAC;AAAEC,MAAAA;AAAF,KAAD,CAAR;AACH;;AAAA;AAED,SAAO;AACHF,IAAAA,KADG;AAEHG,IAAAA,UAFG;AAGHY,IAAAA;AAHG,GAAP;AAKH","sourcesContent":["import { useState, useEffect } from \"react\";\n\n\nexport default function useApplicationData(){\n\n    //This custom hook is the beiung used to manage the overall data of the app.\n    const [state, setState] = useState({\n        array: []\n    });\n\n    //function that generates a new array with randomized numbers\n    function resetArray(){\n        let array = [];\n        for (let i = 0; i <= 290; i++){\n            array.push(Math.floor(Math.random() * (900 - 5 + 1) + 5));\n        }\n        setState({ array });\n    };\n\n    //Once the comonpent loads \n    useEffect(() => {\n        resetArray();\n    }, []);\n\n    //Function that is responsible for comparing the left and right arrays then returning the sortedarray\n    function merge(left, right) {\n        let sortedArray = [];\n  \n        //Looping until one of the arrays has reached 0 elements\n        while (left.length && right.length) {\n            if (left[0] < right[0]) {\n                sortedArray.push(left.shift());\n            } else {\n                sortedArray.push(right.shift());\n            }\n        }\n        //Using the spread operator to concat the sorted elements, with the left and right arrays\n        return [...sortedArray, ...left, ...right];\n    };\n\n    //Main that takes an unsorted array as input and uses recursion to sort it in ascending order\n    function mergeSort(arr) {\n\n        //If the array has 1 or 0 elements then exit out of the function\n        if (arr.length <= 1) {\n        return arr;\n        }\n    \n        //Create the left and right arrays by splitting the original array in the middle\n        const middle = Math.floor(arr.length / 2);\n        let left = arr.slice(0, middle);\n        let right = arr.slice(middle);\n    \n        //Return the sorted array from the merge function\n        let array = merge(mergeSort(left), mergeSort(right));\n        setState({ array });\n    };\n\n    return {\n        state,\n        resetArray,\n        mergeSort\n    }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}