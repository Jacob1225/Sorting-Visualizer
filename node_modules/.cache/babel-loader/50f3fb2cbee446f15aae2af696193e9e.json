{"ast":null,"code":"import { useState, useEffect } from \"react\";\nexport default function useApplicationData() {\n  //This custom hook is the beiung used to manage the overall data of the app.\n  const [state, setState] = useState({\n    array: [],\n    sizeSlider: 50,\n    speedSlider: 1,\n    disabled: false\n  }); //function that generates a new array with randomized numbers\n\n  function resetArray() {\n    let array = [];\n\n    for (let i = 0; i < state.sizeSlider; i++) {\n      array.push(Math.floor(Math.random() * (700 - 5 + 1) + 5));\n    }\n\n    setState(prev => ({ ...prev,\n      array: array\n    }));\n  }\n\n  ; //Once the comonpent loads \n\n  useEffect(() => {\n    resetArray();\n  }, []); //Function that sets the disabled state key to true once a button is clicked\n\n  function disable() {\n    setState(prev => ({ ...prev,\n      disabled: true\n    }));\n  }\n\n  ; //Driver or main function that runs the merge sort algorithm\n\n  function mergeSort(arr) {\n    let colorChange = [];\n    let helperArr = arr.slice();\n    mergePartitions(arr, 0, arr.length - 1, helperArr, colorChange);\n    return colorChange;\n  }\n\n  ; //Function that creates partitions for the array\n\n  function mergePartitions(arr, start, end, helperArr, colorChange) {\n    if (start === end) {\n      return;\n    }\n\n    const middle = Math.floor((start + end) / 2);\n    mergePartitions(helperArr, start, middle, arr, colorChange);\n    mergePartitions(helperArr, middle + 1, end, arr, colorChange);\n    merge(arr, start, middle, end, helperArr, colorChange);\n  }\n\n  ; //Function that compares values and merges the subarrays together\n\n  function merge(arr, start, middle, end, helperArr, colorChange) {\n    let i = start;\n    let k = start;\n    let j = middle + 1; //Compare values in the helper array and overwrite them into the main array \n\n    while (i <= middle && j <= end) {\n      //push the values that are being compared to the color change array to change their color\n      colorChange.push([i, j]); //push them again to change their color back \n\n      colorChange.push([i, j]);\n\n      if (helperArr[i] <= helperArr[j]) {\n        colorChange.push([k, helperArr[i]]);\n        arr[k++] = helperArr[i++];\n      } else {\n        colorChange.push([k, helperArr[j]]);\n        arr[k++] = helperArr[j++];\n      }\n    } //Make sure to copy the left side and right side of the helper array into the main array\n\n\n    while (i <= middle) {\n      colorChange.push([i, i]);\n      colorChange.push([i, i]);\n      colorChange.push([k, helperArr[i]]);\n      arr[k++] = helperArr[i++];\n    }\n\n    while (j <= end) {\n      colorChange.push([j, j]);\n      colorChange.push([j, j]);\n      colorChange.push([k, helperArr[j]]);\n      arr[k++] = helperArr[j++];\n    }\n  }\n\n  ; //function that swaps two values\n\n  function swap(arr, i, j, colorChange) {\n    let temp = arr[i];\n    arr[i] = arr[j]; //push the swap animation to the colorChange array\n\n    colorChange.push([\"swap\", i, arr[j]]);\n    arr[j] = temp;\n    colorChange.push([\"swap\", j, temp]);\n  }\n\n  ; //function that creates a max heap to sort an array in ascending order\n\n  function heapRoot(arr, length, index, colorChange) {\n    let leftChild = 2 * index + 1;\n    let rightChild = 2 * index + 2;\n    let parent = index;\n\n    if (leftChild < length && arr[leftChild] > arr[parent]) {\n      colorChange.push([\"red\", parent, leftChild]);\n      colorChange.push([\"turquoise\", parent, leftChild]);\n      parent = leftChild;\n    }\n\n    if (rightChild < length && arr[rightChild] > arr[parent]) {\n      colorChange.push([\"red\", parent, rightChild]);\n      colorChange.push([\"turquoise\", parent, rightChild]);\n      parent = rightChild;\n    }\n\n    if (parent != index) {\n      swap(arr, parent, index, colorChange);\n      heapRoot(arr, length, parent, colorChange);\n    }\n  }\n\n  ; //Function that uses the max heap data structure to sort the array\n\n  function heapSort(arr) {\n    let colorChange = [];\n    let n = arr.length;\n    let i = Math.floor(n / 2 - 1);\n    let k = n - 1;\n\n    while (i >= 0) {\n      heapRoot(arr, n, i, colorChange);\n      i--;\n    }\n\n    while (k >= 0) {\n      swap(arr, 0, k, colorChange);\n      heapRoot(arr, k, 0, colorChange);\n      k--;\n    }\n\n    return colorChange;\n  }\n\n  ; //Function that sorts an array in ascending order by bubbling elements to their respective positions\n\n  function bubbleSort(arr) {\n    //Color changes array to keep track of the values being compared\n    let colorChanges = []; //Loop through all of the elements of the array\n\n    for (let i = 0; i < arr.length; i++) {\n      let swapped = false;\n\n      for (let j = 0; j < arr.length - i - 1; j++) {\n        //Push the values being compared to the colorChanges array to change their color\n        colorChanges.push([\"red\", j, j + 1]);\n        colorChanges.push([\"turquoise\", j, j + 1]); //If the current element is greater than it's following element then swapped them\n\n        if (arr[j] > arr[j + 1]) {\n          colorChanges.push([\"swap\", j, arr[j + 1]]);\n          colorChanges.push([\"swap\", j + 1, arr[j]]);\n          let temp = arr[j];\n          arr[j] = arr[j + 1];\n          arr[j + 1] = temp; //Set the boolean tracker to true\n\n          swapped = true;\n        } else {\n          colorChanges.push([\"swap\", j, arr[j]]);\n          colorChanges.push([\"swap\", j + 1, arr[j + 1]]);\n        }\n      } //Change the color of the last sorted element\n\n\n      colorChanges.push([arr.length - 1 - i]); //If no elements were swap then break out of the outer loop and the array is sorted\n\n      if (!swapped) {\n        //Need to complete the coloring of sorted elements in the event that we break out of the outer loop\n        const cycles = arr.length - 1 - i;\n\n        for (let k = 0; k < cycles; k++) {\n          i++;\n          colorChanges.push([arr.length - 1 - i]);\n        }\n\n        break;\n      }\n    }\n\n    return colorChanges;\n  }\n\n  ; //Function that sorts an array in ascending order by finding the min value and placing it at the start of the array\n\n  function selectionSort(arr) {\n    let colorChange = []; //Loop through all of the elements in the array\n\n    for (let i = 0; i < arr.length; i++) {\n      let minIndex = i;\n\n      for (let j = i + 1; j < arr.length; j++) {\n        //Add the values being compared to the colorchange array\n        colorChange.push([\"red\", minIndex, j]);\n        colorChange.push([\"turquoise\", minIndex, j]);\n\n        if (arr[minIndex] > arr[j]) {\n          minIndex = j;\n        }\n      } //Add the swap animations to the colorchange array\n\n\n      colorChange.push([\"swap\", i, arr[minIndex]]);\n      colorChange.push([\"swap\", minIndex, arr[i]]);\n      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];\n    }\n\n    return colorChange;\n  }\n\n  ; //Function that sorts an array in ascending order\n\n  function insertionSort(arr) {\n    const n = arr.length;\n    let colorChange = []; //Loop through all of the elements of the array starting at index 1\n\n    for (let i = 1; i < n; i++) {\n      let el = arr[i];\n      let j = i - 1; //removes the el and inserts the preceeding element in its place\n\n      while (j >= 0 && el < arr[j]) {\n        //Add the comparison animations to the color change array\n        colorChange.push([\"red\", i, j]);\n        colorChange.push([\"turquoise\", i, j]); //Add the swap animations to the color change array\n\n        colorChange.push([\"swap\", j + 1, arr[j]]);\n        arr[j + 1] = arr[j];\n        j = j - 1;\n      }\n\n      colorChange.push([\"swap\", j + 1, el]);\n      arr[j + 1] = el;\n    }\n\n    return colorChange;\n  }\n\n  ; //Function that sets the state for the value of the slider \n\n  function sizeChange(e) {\n    let size = e.target.value;\n    setState(prev => ({ ...prev,\n      sizeSlider: size\n    }));\n  }\n\n  ; //Function that sets the state for the value of the slider \n\n  function speedChange(e) {\n    let speed = e.target.value;\n    setState(prev => ({ ...prev,\n      speedSlider: speed\n    }));\n  }\n\n  ;\n  return {\n    state,\n    resetArray,\n    disable,\n    mergeSort,\n    heapSort,\n    bubbleSort,\n    selectionSort,\n    insertionSort,\n    speedChange,\n    sizeChange\n  };\n}\n;","map":{"version":3,"sources":["/Users/jacobcarlone/lighthouse1/Sorting-Visualizer/src/hooks/useApplicationData.jsx"],"names":["useState","useEffect","useApplicationData","state","setState","array","sizeSlider","speedSlider","disabled","resetArray","i","push","Math","floor","random","prev","disable","mergeSort","arr","colorChange","helperArr","slice","mergePartitions","length","start","end","middle","merge","k","j","swap","temp","heapRoot","index","leftChild","rightChild","parent","heapSort","n","bubbleSort","colorChanges","swapped","cycles","selectionSort","minIndex","insertionSort","el","sizeChange","e","size","target","value","speedChange","speed"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\n\n\nexport default function useApplicationData(){\n\n    //This custom hook is the beiung used to manage the overall data of the app.\n    const [state, setState] = useState({\n        array: [],\n        sizeSlider: 50,\n        speedSlider: 1,\n        disabled: false\n    });\n\n    //function that generates a new array with randomized numbers\n    function resetArray(){\n        let array = [];\n        for (let i = 0; i < state.sizeSlider; i++){\n            array.push(Math.floor(Math.random() * (700 - 5 + 1) + 5));\n        }\n        setState(prev => ({\n            ...prev,\n            array: array,\n        }));\n    };\n\n    //Once the comonpent loads \n    useEffect(() => {\n        resetArray();\n    }, []);\n\n//Function that sets the disabled state key to true once a button is clicked\nfunction disable() {\n    setState(prev => ({\n        ...prev,\n        disabled: true\n    }));\n};\n\n//Driver or main function that runs the merge sort algorithm\nfunction mergeSort(arr){\n    let colorChange = [];\n    let helperArr = arr.slice();\n    mergePartitions(arr, 0, arr.length - 1, helperArr, colorChange);\n    return colorChange;\n\n};\n\n//Function that creates partitions for the array\nfunction mergePartitions(arr, start, end, helperArr, colorChange){\n    if (start === end){\n        return;\n    }\n\n    const middle = Math.floor((start + end) / 2);\n    mergePartitions(helperArr, start, middle, arr, colorChange);\n    mergePartitions(helperArr, middle + 1, end, arr, colorChange);\n    merge(arr, start, middle, end, helperArr, colorChange);\n};\n\n//Function that compares values and merges the subarrays together\nfunction merge(arr, start, middle, end, helperArr, colorChange){\n    let i = start;\n    let k = start;\n    let j = middle + 1;\n\n    //Compare values in the helper array and overwrite them into the main array \n    while (i <= middle && j <= end){\n        \n        //push the values that are being compared to the color change array to change their color\n        colorChange.push([i, j]);\n\n        //push them again to change their color back \n        colorChange.push([i, j]);\n\n        if (helperArr[i] <= helperArr[j]){\n            colorChange.push([k, helperArr[i]]);\n            arr[k++] = helperArr[i++];\n        } else {\n            colorChange.push([k, helperArr[j]]);\n            arr[k++] = helperArr[j++];\n        }\n    }\n\n    //Make sure to copy the left side and right side of the helper array into the main array\n    while (i <= middle){\n        colorChange.push([i, i]);\n        colorChange.push([i, i]);\n        colorChange.push([k, helperArr[i]]);\n        arr[k++] = helperArr[i++];\n    }\n\n    while (j <= end){\n        colorChange.push([j, j]);\n        colorChange.push([j, j]);\n        colorChange.push([k, helperArr[j]]);\n        arr[k++] = helperArr[j++];\n    }\n};\n    //function that swaps two values\n    function swap(arr, i, j, colorChange) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n\n        //push the swap animation to the colorChange array\n        colorChange.push([\"swap\", i, arr[j]]);\n\n        arr[j] = temp;\n        colorChange.push([\"swap\", j, temp]);\n       \n    };\n\n    //function that creates a max heap to sort an array in ascending order\n    function heapRoot(arr, length, index, colorChange) {\n        let leftChild = 2 * index + 1;\n        let rightChild = 2 * index + 2;\n        let parent = index;\n    \n        if (leftChild < length && arr[leftChild] > arr[parent]) {\n            colorChange.push([\"red\", parent, leftChild]);\n            colorChange.push([\"turquoise\", parent, leftChild]);\n            parent = leftChild;\n        }\n    \n        if (rightChild < length && arr[rightChild] > arr[parent]) {\n            colorChange.push([\"red\", parent, rightChild]);\n            colorChange.push([\"turquoise\", parent, rightChild]);\n            parent = rightChild;\n        }\n    \n        if (parent != index) {\n            swap(arr, parent, index, colorChange);\n            heapRoot(arr, length, parent, colorChange);\n        }\n    };\n\n    //Function that uses the max heap data structure to sort the array\n    function heapSort(arr) {\n        let colorChange = [];\n        let n = arr.length;\n        let i = Math.floor(n / 2 - 1);\n        let k = n - 1;\n    \n        while (i >= 0) {\n            heapRoot(arr, n, i, colorChange);\n            i--;\n        }\n    \n        while (k >= 0) {\n            swap(arr, 0, k, colorChange);\n            heapRoot(arr, k, 0, colorChange);\n            k--;\n        }\n        return colorChange;\n    };\n\n    //Function that sorts an array in ascending order by bubbling elements to their respective positions\n    function bubbleSort(arr) {\n        \n        //Color changes array to keep track of the values being compared\n        let colorChanges = [];\n\n        //Loop through all of the elements of the array\n        for (let i = 0; i < arr.length; i++) { \n            let swapped = false;\n  \n            for (let j = 0; j < arr.length - i - 1; j++) {\n                \n                //Push the values being compared to the colorChanges array to change their color\n                colorChanges.push([\"red\", j, j + 1]);\n                colorChanges.push([\"turquoise\", j, j + 1]);\n\n                //If the current element is greater than it's following element then swapped them\n                if (arr[j] > arr[j + 1]) {\n\n                    colorChanges.push([\"swap\", j, arr[j + 1]]);\n                    colorChanges.push([\"swap\", j + 1, arr[j]]);\n                    let temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n  \n                    //Set the boolean tracker to true\n                    swapped = true;\n                \n                } else {\n                    colorChanges.push([\"swap\", j, arr[j]]);\n                    colorChanges.push([\"swap\", j + 1, arr[j + 1]]);\n                }\n            }\n            //Change the color of the last sorted element\n            colorChanges.push([arr.length - 1 - i]);\n\n            //If no elements were swap then break out of the outer loop and the array is sorted\n            if (!swapped) {\n                \n                //Need to complete the coloring of sorted elements in the event that we break out of the outer loop\n                const cycles = arr.length - 1 - i;\n                for (let k = 0; k < cycles; k++){\n                    i++;\n                    colorChanges.push([arr.length - 1 - i]);\n                }\n                break;\n            }\n        }\n        return colorChanges;\n  };\n\n    //Function that sorts an array in ascending order by finding the min value and placing it at the start of the array\n    function selectionSort(arr) {\n        \n        let colorChange = [];\n        //Loop through all of the elements in the array\n        for (let i = 0; i < arr.length; i++){\n            let minIndex = i;\n  \n            for (let j = i + 1; j < arr.length; j++){\n\n                //Add the values being compared to the colorchange array\n                colorChange.push([\"red\", minIndex, j]);\n                colorChange.push([\"turquoise\", minIndex, j]);\n\n                if (arr[minIndex] > arr[j]){\n                    minIndex = j;\n                }\n            }\n            //Add the swap animations to the colorchange array\n            colorChange.push([\"swap\", i, arr[minIndex]]);\n            colorChange.push([\"swap\", minIndex, arr[i]]);\n            [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];\n        }\n        return colorChange;\n    };\n\n    //Function that sorts an array in ascending order\n    function insertionSort(arr) {\n        const n = arr.length;\n\n        let colorChange = [];\n  \n        //Loop through all of the elements of the array starting at index 1\n        for (let i = 1; i < n; i++) {\n            \n            let el = arr[i];\n            let j = i - 1;\n  \n            //removes the el and inserts the preceeding element in its place\n            while (j >= 0 && el < arr[j]) {\n\n                //Add the comparison animations to the color change array\n                colorChange.push([\"red\", i, j]);\n                colorChange.push([\"turquoise\", i, j]);\n\n                //Add the swap animations to the color change array\n                colorChange.push([\"swap\", j + 1, arr[j]]);\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            colorChange.push([\"swap\", j + 1, el]);\n            arr[j + 1] = el;\n        }\n        return colorChange;\n    };\n\n    //Function that sets the state for the value of the slider \n    function sizeChange(e){\n        let size = e.target.value;\n        setState(prev => ({\n            ...prev,\n            sizeSlider: size\n        }))\n    };\n\n     //Function that sets the state for the value of the slider \n     function speedChange(e){\n        let speed = e.target.value;\n        setState(prev => ({\n            ...prev,\n            speedSlider: speed\n        }))\n    };\n\n    return {\n        state,\n        resetArray,\n        disable,\n        mergeSort,\n        heapSort,\n        bubbleSort,\n        selectionSort,\n        insertionSort,\n        speedChange,\n        sizeChange,\n    }\n};\n\n\n"]},"metadata":{},"sourceType":"module"}