{"ast":null,"code":"import { useState, useEffect } from \"react\";\nexport default function useApplicationData() {\n  //This custom hook is the beiung used to manage the overall data of the app.\n  const [state, setState] = useState({\n    array: []\n  }); //function that generates a new array with randomized numbers\n\n  function resetArray() {\n    let array = [];\n\n    for (let i = 0; i <= 5; i++) {\n      array.push(Math.floor(Math.random() * (800 - 5 + 1) + 5));\n    }\n\n    setState({\n      array\n    });\n  }\n\n  ; //Once the comonpent loads \n\n  useEffect(() => {\n    resetArray();\n  }, []); // //Function that is responsible for comparing the left and right arrays then returning the sortedarray\n  // function merge(left, right) {\n  //     let sortedArray = [];\n  //     //Looping until one of the arrays has reached 0 elements\n  //     while (left.length && right.length) {\n  //         if (left[0] < right[0]) {\n  //             sortedArray.push(left.shift());\n  //         } else {\n  //             sortedArray.push(right.shift());\n  //         }\n  //     }\n  //     //Using the spread operator to concat the sorted elements, with the left and right arrays\n  //     setState({\n  //         array: [...sortedArray, ...left, ...right]\n  //     })\n  //     return [...sortedArray, ...left, ...right];\n  // };\n  // //Main that takes an unsorted array as input and uses recursion to sort it in ascending order\n  // function mergeSort(arr) {\n  //     //If the array has 1 or 0 elements then exit out of the function\n  //     if (arr.length <= 1) {\n  //     return arr;\n  //     }\n  //     //Create the left and right arrays by splitting the original array in the middle\n  //     const middle = Math.floor(arr.length / 2);\n  //     let left = arr.slice(0, middle);\n  //     let right = arr.slice(middle);\n  //     //Return the sorted array from the merge function\n  //     return merge(mergeSort(left), mergeSort(right));\n  // };\n  //Function that will seperate the array in halves\n\n  function mergeSort(arr) {\n    //If the array has 1 element then it is already sorted thus return\n    if (arr.length <= 1) {\n      return arr;\n    } //Create two arrays by dividing the array in half\n\n\n    const middleIndex = Math.floor(arr.length / 2);\n    const leftArray = arr.slice(0, middleIndex);\n    const rightArray = arr.slice(middleIndex); //Use recursion to sort the halves\n\n    mergeSort(leftArray);\n    mergeSort(rightArray); //Start compare the values and swapping them in the array\n\n    let k = 0;\n    let i = 0;\n    let j = 0; //Loop until i or j is greater than their array length\n\n    while (i < leftArray.length && j < rightArray.length) {\n      //Compare the values of each half\n      if (leftArray[i] <= rightArray[j]) {\n        arr[k++] = leftArray[i++];\n      } else {\n        arr[k++] = rightArray[j++];\n      }\n    } //Make sure that all values are overwritten to the main array\n\n\n    while (i < leftArray.length) {\n      arr[k++] = leftArray[i++];\n    }\n\n    while (j < rightArray.length) {\n      arr[k++] = rightArray[j++];\n    }\n\n    setState({\n      array: arr\n    });\n  }\n\n  ; //function that swaps two values\n\n  function swap(arr, i, j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  ; //function that creates a max heap to sort an array in ascending order\n\n  function heapRoot(arr, length, index) {\n    let leftChild = 2 * index + 1;\n    let rightChild = 2 * index + 2;\n    let parent = index;\n\n    if (leftChild < length && arr[leftChild] > arr[parent]) {\n      parent = leftChild;\n    }\n\n    if (rightChild < length && arr[rightChild] > arr[parent]) {\n      parent = rightChild;\n    }\n\n    if (parent != index) {\n      swap(arr, parent, index);\n      heapRoot(arr, length, parent);\n    }\n  }\n\n  ; //Function that uses the max heap data structure to sort the array\n\n  function heapSort(arr) {\n    let n = arr.length;\n    let i = Math.floor(n / 2 - 1);\n    let k = n - 1;\n\n    while (i >= 0) {\n      heapRoot(arr, n, i);\n      i--;\n    }\n\n    while (k >= 0) {\n      swap(arr, 0, k);\n      heapRoot(arr, k, 0);\n      k--;\n    }\n\n    setState({\n      array: arr\n    });\n  }\n\n  ; //Function that sorts an array in ascending order by bubbling elements to their respective positions\n\n  function bubbleSort(arr) {\n    //Loop through all of the elements of the array\n    for (let i = 0; i < arr.length; i++) {\n      let swapped = false;\n\n      for (let j = 0; j < arr.length - i - 1; j++) {\n        //If the current element is greater than it's following element then swapped them\n        if (arr[j] > arr[j + 1]) {\n          let temp = arr[j];\n          arr[j] = arr[j + 1];\n          arr[j + 1] = temp; //Set the boolean tracker to true\n\n          swapped = true;\n        }\n      } //If no elements were swap then break out of the outer loop and the array is sorted\n\n\n      if (!swapped) {\n        break;\n      }\n    }\n\n    setState({\n      array: arr\n    });\n  }\n\n  ; //Function that sorts an array in ascending order by finding the min value and placing it at the start of the array\n\n  function selectionSort(arr) {\n    //Loop through all of the elements in the array\n    for (let i = 0; i < arr.length; i++) {\n      let minIndex = i;\n\n      for (let j = i + 1; j < arr.length; j++) {\n        if (arr[minIndex] > arr[j]) {\n          minIndex = j;\n        }\n      }\n\n      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];\n    }\n\n    setState({\n      array: arr\n    });\n  }\n\n  ; //Function that sorts an array in ascending order\n\n  function insertionSort(arr) {\n    const n = arr.length; //Loop through all of the elements of the array starting at index 1\n\n    for (let i = 1; i < n; i++) {\n      let el = arr[i];\n      let j = i - 1; //removes the el and inserts the preceeding element in its place\n\n      while (j >= 0 && el < arr[j]) {\n        arr[j + 1] = arr[j];\n        j = j - 1;\n      }\n\n      arr[j + 1] = el;\n    }\n\n    setState({\n      array: arr\n    });\n  }\n\n  ;\n  return {\n    state,\n    resetArray,\n    mergeSort,\n    heapSort,\n    bubbleSort,\n    selectionSort,\n    insertionSort\n  };\n}\n;","map":{"version":3,"sources":["/Users/jacobcarlone/lighthouse1/Sorting-Visualizer/sorting-visualizer/src/hooks/useApplicationData.jsx"],"names":["useState","useEffect","useApplicationData","state","setState","array","resetArray","i","push","Math","floor","random","mergeSort","arr","length","middleIndex","leftArray","slice","rightArray","k","j","swap","temp","heapRoot","index","leftChild","rightChild","parent","heapSort","n","bubbleSort","swapped","selectionSort","minIndex","insertionSort","el"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\n\n\nexport default function useApplicationData(){\n\n    //This custom hook is the beiung used to manage the overall data of the app.\n    const [state, setState] = useState({\n        array: []\n    });\n\n    //function that generates a new array with randomized numbers\n    function resetArray(){\n        let array = [];\n        for (let i = 0; i <= 5; i++){\n            array.push(Math.floor(Math.random() * (800 - 5 + 1) + 5));\n        }\n        setState({ array });\n    };\n\n    //Once the comonpent loads \n    useEffect(() => {\n        resetArray();\n    }, []);\n\n    // //Function that is responsible for comparing the left and right arrays then returning the sortedarray\n    // function merge(left, right) {\n    //     let sortedArray = [];\n  \n    //     //Looping until one of the arrays has reached 0 elements\n    //     while (left.length && right.length) {\n    //         if (left[0] < right[0]) {\n    //             sortedArray.push(left.shift());\n    //         } else {\n    //             sortedArray.push(right.shift());\n    //         }\n    //     }\n    //     //Using the spread operator to concat the sorted elements, with the left and right arrays\n    //     setState({\n    //         array: [...sortedArray, ...left, ...right]\n    //     })\n    //     return [...sortedArray, ...left, ...right];\n    // };\n\n    // //Main that takes an unsorted array as input and uses recursion to sort it in ascending order\n    // function mergeSort(arr) {\n\n    //     //If the array has 1 or 0 elements then exit out of the function\n    //     if (arr.length <= 1) {\n    //     return arr;\n    //     }\n    \n    //     //Create the left and right arrays by splitting the original array in the middle\n    //     const middle = Math.floor(arr.length / 2);\n    //     let left = arr.slice(0, middle);\n    //     let right = arr.slice(middle);\n    \n    //     //Return the sorted array from the merge function\n    //     return merge(mergeSort(left), mergeSort(right));\n    // };\n\n    //Function that will seperate the array in halves\n    function mergeSort(arr){\n    \n        //If the array has 1 element then it is already sorted thus return\n        if (arr.length <= 1){\n            return arr;\n        }\n\n        //Create two arrays by dividing the array in half\n        const middleIndex = Math.floor(arr.length / 2);\n        const leftArray = arr.slice(0, middleIndex);\n        const rightArray = arr.slice(middleIndex); \n\n        //Use recursion to sort the halves\n        mergeSort(leftArray);\n        mergeSort(rightArray);\n\n        //Start compare the values and swapping them in the array\n        let k = 0;\n        let i = 0;\n        let j = 0;\n\n        //Loop until i or j is greater than their array length\n        while (i < leftArray.length && j < rightArray.length){\n        \n            //Compare the values of each half\n            if (leftArray[i] <= rightArray[j]){\n                arr[k++] = leftArray[i++];\n            } else {\n                arr[k++] = rightArray[j++];\n            }\n        }\n\n        //Make sure that all values are overwritten to the main array\n        while (i < leftArray.length){\n            arr[k++] = leftArray[i++];\n        }\n\n        while (j < rightArray.length){\n            arr[k++] = rightArray[j++];\n        }\n\n        setState({\n            array: arr\n        });\n    };\n    //function that swaps two values\n    function swap(arr, i, j) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    };\n\n    //function that creates a max heap to sort an array in ascending order\n    function heapRoot(arr, length, index) {\n        let leftChild = 2 * index + 1;\n        let rightChild = 2 * index + 2;\n        let parent = index;\n    \n        if (leftChild < length && arr[leftChild] > arr[parent]) {\n            parent = leftChild;\n        }\n    \n        if (rightChild < length && arr[rightChild] > arr[parent]) {\n            parent = rightChild;\n        }\n    \n        if (parent != index) {\n            swap(arr, parent, index);\n            heapRoot(arr, length, parent);\n        }\n    };\n\n    //Function that uses the max heap data structure to sort the array\n    function heapSort(arr) {\n        let n = arr.length;\n        let i = Math.floor(n / 2 - 1);\n        let k = n - 1;\n    \n        while (i >= 0) {\n            heapRoot(arr, n, i);\n            i--;\n        }\n    \n        while (k >= 0) {\n            swap(arr, 0, k);\n            heapRoot(arr, k, 0);\n            k--;\n        }\n    \n        setState({\n            array: arr\n        });\n    };\n\n    //Function that sorts an array in ascending order by bubbling elements to their respective positions\n    function bubbleSort(arr) {\n        \n        //Loop through all of the elements of the array\n        for (let i = 0; i < arr.length; i++) { \n            let swapped = false;\n  \n            for (let j = 0; j < arr.length - i - 1; j++) {\n        \n                //If the current element is greater than it's following element then swapped them\n                if (arr[j] > arr[j + 1]) {\n                    let temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n  \n                    //Set the boolean tracker to true\n                    swapped = true;\n                }\n            }\n            //If no elements were swap then break out of the outer loop and the array is sorted\n            if (!swapped) {\n                break;\n            }\n        }\n  \n        setState({\n            array: arr\n        });\n  };\n\n    //Function that sorts an array in ascending order by finding the min value and placing it at the start of the array\n    function selectionSort(arr) {\n  \n        //Loop through all of the elements in the array\n        for (let i = 0; i < arr.length; i++){\n            let minIndex = i;\n  \n            for (let j = i + 1; j < arr.length; j++){\n                if (arr[minIndex] > arr[j]){\n                    minIndex = j;\n                }\n            }\n            [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];\n        }\n        setState({\n            array: arr\n        });\n    };\n\n    //Function that sorts an array in ascending order\n    function insertionSort(arr) {\n        const n = arr.length;\n  \n        //Loop through all of the elements of the array starting at index 1\n        for (let i = 1; i < n; i++) {\n            \n            let el = arr[i];\n            let j = i - 1;\n  \n            //removes the el and inserts the preceeding element in its place\n            while (j >= 0 && el < arr[j]) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n  \n            arr[j + 1] = el;\n        }\n        setState({\n            array: arr\n        });\n    };\n\n    return {\n        state,\n        resetArray,\n        mergeSort,\n        heapSort,\n        bubbleSort,\n        selectionSort,\n        insertionSort\n    }\n};\n\n\n"]},"metadata":{},"sourceType":"module"}